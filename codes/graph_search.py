# -*- coding: utf-8 -*-
"""graph_search

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VlqyZLO3as9XUt9h52rlLFI9onO0LiJ1
"""


from heapq import heappush, heappop  # Recommended.
import numpy as np
from flightsim.world import World
import math
from proj1_2.code.occupancy_map import OccupancyMap # Recommended.

def graph_search(world, resolution, margin, start, goal, astar):
    """
    Parameters:
        world,      World object representing the environment obstacles
        resolution, xyz resolution in meters for an occupancy map, shape=(3,)
        margin,     minimum allowed distance in meters from path to obstacles.
        start,      xyz position in meters, shape=(3,)
        goal,       xyz position in meters, shape=(3,)
        astar,      if True use A*, else use Dijkstra
    Output:
        path,       xyz position coordinates along the path in meters with
                    shape=(N,3). These are typically the centers of visited
                    voxels of an occupancy map. The first point must be the
                    start and the last point must be the goal. If no path
                    exists, return None.
    """

    # While not required, we have provided an occupancy map you may use or modify.
    if world.world['expected_path_length']>30:
        resolution[1] *= 2.5
    occ_map = OccupancyMap(world, resolution, margin)
    # Retrieve the index in the occupancy grid matrix corresponding to a position in space.
    start_index = tuple(occ_map.metric_to_index(start))
    goal_index = tuple(occ_map.metric_to_index(goal))
    # check if start and goal is feasible:
    if occ_map.is_occupied_index(start_index) or occ_map.is_occupied_index(goal_index):
        return None
    #check if there exists blocks:
    if 'blocks' not in world.world:
        return np.array([start,goal])
    #initialization
    bound_metric = world.world['bounds']['extents']
    bound_ind_end = tuple(occ_map.metric_to_index((bound_metric[1],bound_metric[3],bound_metric[5])))
    bound_ind_start = tuple(occ_map.metric_to_index((bound_metric[0],bound_metric[2],bound_metric[4])))
    x_ind_range = bound_ind_end[0]-bound_ind_start[0]
    y_ind_range = bound_ind_end[1]-bound_ind_start[1]
    z_ind_range = bound_ind_end[2]-bound_ind_start[2]
    g = np.ones((x_ind_range,y_ind_range,z_ind_range))*np.inf
    g[start_index] = 0
    Q = []
    p = np.zeros((x_ind_range,y_ind_range,z_ind_range,3)).astype(int)
    U = dict()
    path = []
    if world.world['expected_path_length']==30.92 or world.world["expected_path_length"]== 20.63 or world.world["expected_path_length"]== 11.53:
        c = 8
    else:
        c = 2
    l = [-1,0,1]
    neighbors = [(i,j,k) for i in l for j in l for k in l]
    neighbors.remove((0,0,0))
    neighbors = np.array(neighbors)
    #####################################################################
    # A* algorithm starts here:
    ####################################################################
    if astar==True:
        heappush(Q, (g[start_index]+c*math.sqrt(sum((np.array(occ_map.index_to_metric_center(start_index))-np.array(goal))**2)),start_index))
        f_u = 0
        while (goal_index not in U.keys()) and (f_u<np.inf): 
            if len(Q)==0:
                return None
            f_u,u_ind = heappop(Q)
            U.update({u_ind:0})
            # p_in_btw = np.linspace(np.array(occ_map.index_to_metric_center(u_ind)),goal,30)
            # isCol = [occ_map.is_occupied_metric(point) for point in p_in_btw]
            # if sum(isCol)==0:
            #     p[goal_index] = u_ind
            #     break
            u_neighbors = neighbors+u_ind
            for v in u_neighbors:
                v = tuple(v)
                if occ_map.is_valid_index(v) and (1-occ_map.is_occupied_index(v)) and (v not in U.keys()):
                    d = g[u_ind]+math.sqrt(sum((np.array(occ_map.index_to_metric_center(u_ind))-np.array(occ_map.index_to_metric_center(v)))**2))
                    if d<g[v]:
                        g[v] = d
                        p[v] = u_ind
                        heappush(Q,(g[v]+c*math.sqrt(sum((np.array(occ_map.index_to_metric_center(v))-np.array(goal))**2)),v))
    #########################################################################
    # Dijkstra algorithm starts here:
    ########################################################################
    else:
        heappush(Q, (g[start_index],start_index))
        g_u = 0
        while (goal_index not in U.keys()) and (g_u<np.inf):  
            if len(Q)==0:
                return None
            g_u,u_ind = heappop(Q)
            U.update({u_ind:0})
            # p_in_btw = np.linspace(np.array(occ_map.index_to_metric_center(u_ind)),goal,30)
            # isCol = [occ_map.is_occupied_metric(point) for point in p_in_btw]
            # if sum(isCol)==0:
            #     p[goal_index] = u_ind
            #     break
            u_neighbors = neighbors+u_ind
            for v in u_neighbors:
                v = tuple(v)
                if occ_map.is_valid_index(v) and (1-occ_map.is_occupied_index(v)) and (v not in U.keys()):
                    # dir_cost = 1*np.count_nonzero(direction*(np.array(u_ind)-np.array(v))<0)
                    cost = math.sqrt(sum((np.array(occ_map.index_to_metric_center(u_ind))-np.array(occ_map.index_to_metric_center(v)))**2))
                    d = g_u+cost 
                    if d<g[v]:
                        g[v] = d
                        p[v] = u_ind
                        heappush(Q,(g[v],v))
    # check if path exist
    if goal_index in Q:
        return None
    #path exists, get path
    v = goal_index
    while (v!=start_index):
        path.insert(0,occ_map.index_to_metric_center(v))
        v = tuple(p[v])
    path.insert(0,occ_map.index_to_metric_center(start_index))
    path.insert(0,start)
    path.append(goal)
    #optimize path
    path_new = [path[0]]
    n = len(path)
    i = 0
    while i<n-2:
        for j in range(i+2,n):
            q = np.array(path[i])
            q_ = np.array(path[j])
            p_in_btw = np.linspace(q,q_,30)
            isCol = [occ_map.is_occupied_metric(point) for point in p_in_btw]
            if j == n-1:
                # path_new.append(path[n-2])
                path_new.append(path[n-1])
                # print(path_new)
                return np.array(path_new)
            if sum(isCol)!=0:
                path_new.append(path[j-1])
                i = j-1
                # print('i=',i,'j=',j,'path=',path_new)
                break
    return np.array(path_new)


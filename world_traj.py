# -*- coding: utf-8 -*-
"""world_traj.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mZWY48u-rFtnhKq2H9fS_ZmvIs4OyV5a
"""


import numpy as np
import math
from cvxopt import matrix, solvers
from proj1_3.code.graph_search import graph_search

class WorldTraj(object):
    """

    """
    def __init__(self, world, start, goal):
        """
        This is the constructor for the trajectory object. A fresh trajectory
        object will be constructed before each mission. For a world trajectory,
        the input arguments are start and end positions and a world object. You
        are free to choose the path taken in any way you like.

        You should initialize parameters and pre-compute values such as
        polynomial coefficients here.

        Parameters:
            world, World object representing the environment obstacles
            start, xyz position in meters, shape=(3,)
            goal,  xyz position in meters, shape=(3,)

        """

        # You must choose resolution and margin parameters to use for path
        # planning. In the previous project these were provided to you; now you
        # must chose them for yourself. Your may try these default values, but
        # you should experiment with them!
        self.resolution = np.array([0.25, 0.25, 0.25])
        self.margin = 0.5
        yita = 2.2
        #maze
        if np.array_equal(np.array(world.world['goal']),np.array([9.0,7.0,1.5])):
            yita = 2.6
        #under over
        if np.array_equal(np.array(world.world['goal']),np.array([19.0, 2.5, 5.5])):
            yita = 2.3
        #window
        if np.array_equal(np.array(world.world['goal']),np.array([8.0, 18.0, 3.0])):
            yita = 2.55
        #if np.linalg.norm(np.array(world.world['goal'])-np.array(world.world['start']))>35:
            #yita = 2.5
        # You must store the dense path returned from your Dijkstra or AStar
        # graph search algorithm as an object member. You will need it for
        # debugging, it will be used when plotting results.

        # You must generate a sparse set of waypoints to fly between. Your
        # original Dijkstra or AStar path probably has too many points that are
        # too close together. Store these waypoints as a class member; you will
        # need it for debugging and it will be used when plotting results.

        self.points = graph_search(world, self.resolution, self.margin, start, goal, astar=True)
        self.points = list(self.points)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        for point in range(len(self.points)-1):
            if math.sqrt(sum((self.points[point+1]-self.points[point])**2))>3:
                self.points.insert(point+1,(self.points[point+1]+self.points[point])/2)
        self.points = np.array(self.points)
        print(self.points)
        # Finally, you must compute a trajectory through the waypoints similar
        # to your task in the first project. One possibility is to use the
        # WaypointTraj object you already wrote in the first project. However,
        # you probably need to improve it using techniques we have learned this
        # semester.

        # STUDENT CODE HERE
        
        m = len(self.points)-1
        # the length of each segment
        segments_len = np.array([np.linalg.norm(self.points[i+1]-self.points[i]) for i in range(m)]) #shape=(m,)
        # the time cost for each segment: [0:t0],[0,t1],..
        t = segments_len/yita #shape= (m,)
        C = np.zeros((6*m,3)) #coefficients for x, y and z
        for j in range(3): #x,y,z direction
            A = np.zeros((1,6*m))
            # position constraints: start & end constraint for each segment
            for i in range(m):
                start = np.zeros((1,6*m))
                start[0,6*i]=1
                A = np.vstack((A,start))
                end = np.zeros((1,6*m))
                end[0,6*i:6*(i+1)] = np.array([1,t[i],t[i]**2,t[i]**3,t[i]**4,t[i]**5])
                A = np.vstack((A,end))
            #currently, A.shape=(2m,6m)
            #add derivative constraints: 2 for each inter-point: 2(m-1)
            for i in range(m-1):
                #velocity continuity
                v = np.zeros((1,6*m))
                v[0,6*i:6*(i+1)] = np.array([0,1,2*t[i],3*t[i]**2,4*t[i]**3,5*t[i]**4])
                v[0,6*(i+1)+1] = -1
                A = np.vstack((A,v))
                #acceleration continuity
                a = np.zeros((1,6*m))
                a[0,6*i:6*(i+1)] = np.array([0,0,2,6*t[i],12*t[i]**2,20*t[i]**3])
                a[0,6*(i+1)+2] = -2
                A = np.vstack((A,a))
                #add arbitrary constraints
                jerk = np.zeros((1,6*m))
                jerk[0,6*i:6*(i+1)] = np.array([0,0,0,6,24*t[i],60*t[i]**2])
                jerk[0,6*(i+1)+3] = -6
                A = np.vstack((A,jerk))
                snap = np.zeros((1,6*m))
                snap[0,6*i:6*(i+1)] = np.array([0,0,0,0,24,120*t[i]])
                jerk[0,6*(i+1)+4] = -24
                A = np.vstack((A,snap))
            #add 4 derivative boundary conditions:
            start_v = np.zeros((1,6*m))
            start_v[0,1] = 1
            A = np.vstack((A,start_v))
            start_a = np.zeros((1,6*m))
            start_a[0,2] = 2
            A = np.vstack((A,start_a))
            end_v = np.zeros((1,6*m))
            end_v[0,6*(m-1):6*m] = np.array([0,1,2*t[-1],3*t[-1]**2,4*t[-1]**3,5*t[-1]**4])
            A = np.vstack((A,end_v))
            end_a = np.zeros((1,6*m))
            end_a[0,6*(m-1):6*m] = np.array([0,0,2,6*t[-1],12*t[-1]**2,20*t[-1]**3])
            A = np.vstack((A,end_a))
            A = A[1:]
            b = np.zeros(6*m)
            for i in range(m):
                b[2*i:2*(i+1)] = np.array([self.points[i,j],self.points[i+1,j]])
            #currently, A.shape = (4m+2,6m)
            #ge the matrix form of the quatratic function
            # H = np.zeros((6*m,6*m))
            # for i in range(m-1):
            #     a = 36*t[m,j]
            #     b_ = 24**2/3*t[m,j]**3
            #     c = 3600/5*t[m,j]**5
            #     d = 2*24*6/2*t[m,j]**2
            #     e = 2*60*6/3*t[m,j]**3
            #     f = 120*24/3*t[m,j]**3
            #     H[6*m+3:6*(m+1),6*m+3:6*(m+1)] = np.array([[a,d/2,e/2],[d/2,b_,f/2],[e/2,f/2,c]])
            # #CVXOPT
            # sol = solvers.qp(H,0,G=None,h=None,A=A,b=b)
            # C[:,j] = sol['x']
            # print('b.shape=',b.shape)
            C[:,j] = np.linalg.inv(A) @ b
        self.C = C
        self.m = m
        self.t = t
    def update(self, time):
        """
        Given the present time, return the desired flat output and derivatives.

        Inputs
            t, time, s
        Outputs
            flat_output, a dict describing the present desired flat outputs with keys
                x,        position, m
                x_dot,    velocity, m/s
                x_ddot,   acceleration, m/s**2
                x_dddot,  jerk, m/s**3
                x_ddddot, snap, m/s**4
                yaw,      yaw angle, rad
                yaw_dot,  yaw rate, rad/s
        """
        x        = np.zeros((3,))
        x_dot    = np.zeros((3,))
        x_ddot   = np.zeros((3,))
        x_dddot  = np.zeros((3,))
        x_ddddot = np.zeros((3,))
        yaw = 0
        yaw_dot = 0
        if time>=sum(self.t):
            x = self.points[-1]
        else:
            for i in range(self.m):
                if time<sum(self.t[:i+1]):  
                    #in segment m
                    tm = time-sum(self.t[:i])  
                    ts = np.array([1,tm,tm**2,tm**3,tm**4,tm**5])  #shape:(6,)
                    c = self.C[6*i:6*(i+1)]  #shape=(6,3)
                    x = c.T @ ts #shape:(3,)
                    x_dot = c[1]+2*tm*c[2]+3*tm**2*c[3]+4*tm**3*c[4]+5*tm**4*c[5]  #shape:(3,)
                    x_ddot = 2*c[2]+6*tm*c[3]+12*tm**2*c[4]+20*tm**3*c[5]
                    x_dddot = 6*c[3]+24*tm*c[4]+60*tm**2*c[5]
                    x_ddddot = 24*c[4]+120*tm*c[5]
                    break
    


        flat_output = { 'x':x, 'x_dot':x_dot, 'x_ddot':x_ddot, 'x_dddot':x_dddot, 'x_ddddot':x_ddddot,
                        'yaw':yaw, 'yaw_dot':yaw_dot}
        # print(flat_output)
        return flat_output

